#!/usr/bin/env node
/**
 * Constants Generator
 *
 * Parses C header files to extract #define constants and generates
 * TypeScript constants file to ensure synchronization between C and TS layers.
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CONSTANTS_HEADER = path.join(__dirname, '../native/include/constants.h');
const OUTPUT_FILE = path.join(__dirname, '../src/constants/limits.generated.ts');

// Regex patterns for parsing C #define directives
const DEFINE_PATTERN = /^#define\s+([A-Z_]+)\s+(\d+)\s*(?:\/\*\s*(.+?)\s*\*\/)?/;

/**
 * Parse C header file and extract constants
 * @param {string} headerPath - Path to C header file
 * @returns {Array<{name: string, value: number, comment: string}>}
 */
function parseConstants(headerPath) {
  if (!fs.existsSync(headerPath)) {
    console.error(`ERROR: Constants header not found: ${headerPath}`);
    process.exit(1);
  }

  const content = fs.readFileSync(headerPath, 'utf-8');
  const lines = content.split('\n');
  const constants = [];

  let inConstantsBlock = false;

  for (const line of lines) {
    const trimmed = line.trim();

    // Start parsing after we see the comment block
    if (trimmed.includes('Core field length limits') ||
        trimmed.includes('Display and formatting constants')) {
      inConstantsBlock = true;
      continue;
    }

    // Stop at #endif
    if (trimmed.startsWith('#endif')) {
      break;
    }

    if (inConstantsBlock && trimmed.startsWith('#define')) {
      const match = trimmed.match(DEFINE_PATTERN);
      if (match) {
        const [, name, value, comment] = match;
        constants.push({
          name,
          value: parseInt(value, 10),
          comment: comment || ''
        });
      }
    }
  }

  if (constants.length === 0) {
    console.error('ERROR: No constants found in header file');
    console.error('Expected format: #define CONSTANT_NAME 123');
    process.exit(1);
  }

  // Validate expected constants exist
  const required = ['MAX_NAME_LEN', 'MAX_DETAIL_LEN', 'MAX_USERID_LEN'];
  const found = constants.map(c => c.name);
  const missing = required.filter(r => !found.includes(r));

  if (missing.length > 0) {
    console.error(`ERROR: Missing required constants: ${missing.join(', ')}`);
    process.exit(1);
  }

  return constants;
}

/**
 * Generate TypeScript constants file
 * @param {Array} constants - Parsed constants
 * @returns {string} TypeScript file content
 */
function generateTypeScript(constants) {
  const timestamp = new Date().toISOString();

  let output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file is automatically generated from native/include/constants.h
 * Generated at: ${timestamp}
 *
 * To regenerate: npm run generate:constants
 */

`;

  // Group constants by category
  const coreConstants = constants.filter(c =>
    c.name.includes('MAX_NAME_LEN') || c.name.includes('MAX_DETAIL_LEN') || c.name.includes('MAX_USERID_LEN')
  );

  const displayConstants = constants.filter(c =>
    c.name.includes('PREVIEW') || c.name.includes('THRESHOLD')
  );

  // Core field limits
  if (coreConstants.length > 0) {
    output += `/** Core field length limits (characters, excluding null terminator in C) */\n`;
    for (const { name, value, comment } of coreConstants) {
      if (comment) {
        output += `/** ${comment} */\n`;
      }
      output += `export const ${name} = ${value};\n\n`;
    }
  }

  // Display constants
  if (displayConstants.length > 0) {
    output += `/** Display and formatting constants */\n`;
    for (const { name, value, comment } of displayConstants) {
      if (comment) {
        output += `/** ${comment} */\n`;
      }
      output += `export const ${name} = ${value};\n\n`;
    }
  }

  // Add convenience object for type safety
  output += `/**
 * All string length limits in a single object for convenience
 */
export const STRING_LIMITS = {
  MAX_NAME_LEN,
  MAX_DETAIL_LEN,
  MAX_USERID_LEN,
  DETAIL_PREVIEW_LEN,
  JSON_EMBED_THRESHOLD
} as const;

/**
 * Type representing all string limit constant names
 */
export type StringLimitKey = keyof typeof STRING_LIMITS;
`;

  return output;
}

/**
 * Main execution
 */
function main() {
  console.log('Generating TypeScript constants from C headers...');
  console.log(`Source: ${CONSTANTS_HEADER}`);
  console.log(`Output: ${OUTPUT_FILE}`);

  // Parse C header
  const constants = parseConstants(CONSTANTS_HEADER);
  console.log(`Found ${constants.length} constants:`);
  constants.forEach(c => console.log(`  - ${c.name} = ${c.value}`));

  // Generate TypeScript
  const tsContent = generateTypeScript(constants);

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write output
  fs.writeFileSync(OUTPUT_FILE, tsContent, 'utf-8');
  console.log(`âœ“ Successfully generated ${OUTPUT_FILE}`);
}

// Run if called directly
if (require.main === module) {
  try {
    main();
  } catch (error) {
    console.error('ERROR:', error.message);
    process.exit(1);
  }
}

module.exports = { parseConstants, generateTypeScript };
